## Обзор структуры проекта gRPC

Этот документ предоставляет обзор файлов и их взаимодействий в учебном проекте gRPC. Ниже описан каждый файл с точки зрения его роли, предоставляемых сервисов, взаимодействия файлов и процессов генерации кода.

### Структура проекта
- **Makefile** (`week_1/grpc/Makefile`)
- **Proto файлы** (`week_1/grpc/api/note_v1/note.proto`)
- **Сгенерированный Go код** (`pkg/note_v1/note.pb.go` и `pkg/note_v1/note_grpc.pb.go`)
- **Реализация сервера** (`week_1/grpc/cmd/grpc_server/main.go`)
- **Реализация клиента** (`week_1/grpc/cmd/grpc_client/main.go`)
- **Сравнение размера данных** (`week_1/grpc/cmd/data_size/main.go`)
- **Генераторы кода** (`bin/protoc-gen-go`, `bin/protoc-gen-go-grpc`)

### Makefile
`Makefile` содержит несколько команд, которые помогают управлять зависимостями, генерировать код и показывать доступные команды. В частности:
- `install-deps` устанавливает необходимые зависимости для генерации кода из proto-файлов с использованием `protoc-gen-go` и `protoc-gen-go-grpc`.
- `get-deps` обновляет зависимости компилятора proto.
- `generate` используется для генерации Go кода из proto-файлов.
- `generate-note-api` специально генерирует Go код для API `note_v1` из файла `note.proto`.

Makefile играет ключевую роль в автоматизации процесса генерации кода из `.proto` файлов.

### Proto файлы
- **`week_1/grpc/api/note_v1/note.proto`**

  Этот файл определяет структуру сообщений и сервисов, используемых в проекте. Он использует синтаксис `proto3` и определяет несколько типов сообщений, таких как `NoteInfo`, `Note`, `UpdateNoteInfo` и другие. Proto файл также определяет сервис `NoteV1`, который предоставляет следующие RPC методы:
    - `Create(CreateRequest)`: Создает новую заметку.
    - `Get(GetRequest)`: Получает заметку по её ID.
    - `List(ListRequest)`: Список заметок с пагинацией.
    - `Update(UpdateRequest)`: Обновляет заметку, используя nullable поля для выборочного обновления.
    - `Delete(UpdateRequest)`: Удаляет заметку.

  `google.protobuf.StringValue` используется для nullable полей в сообщении `UpdateNoteInfo`, что позволяет пропускать поля при обновлении, избегая нежелательных перезаписей пустыми значениями.

### Сгенерированный Go код
- **`pkg/note_v1/note.pb.go`** и **`pkg/note_v1/note_grpc.pb.go`**

  Эти файлы автоматически генерируются из файла `note.proto` и не должны изменяться вручную.

    - **`note.pb.go`**: Содержит Go-определения для сообщений и сервисов. Это включает определения структур сообщений, таких как `NoteInfo`, `Note`, `CreateRequest` и другие.
    - **`note_grpc.pb.go`**: Содержит определения интерфейсов gRPC клиента и сервера для сервиса `NoteV1`. Включает как заглушки на стороне клиента (например, `NoteV1Client`), так и скелеты сервера (например, `NoteV1Server`).
- Приватный метод интерфейса mustEmbedUnimplementedNoteV1Server

В интерфейсе NoteV1Server присутствует приватный метод mustEmbedUnimplementedNoteV1Server(). Этот метод служит для обеспечения forward-совместимости (совместимости с будущими версиями).

Forward-совместимость означает, что реализация сервера должна оставаться совместимой с будущими версиями, где могут добавляться новые методы.

Приватный метод mustEmbedUnimplementedNoteV1Server() играет роль механизма принуждения. Он гарантирует, что реализация интерфейса NoteV1Server должна явно включать в себя встроенную структуру UnimplementedNoteV1Server. Эта структура содержит базовую реализацию всех методов интерфейса, возвращающих ошибку Unimplemented. Если разработчик попытается реализовать NoteV1Server напрямую, не включая UnimplementedNoteV1Server, компилятор выдаст ошибку, поскольку отсутствует реализация приватного метода.

Зачем это нужно?

Защита от изменений интерфейса: В будущем в интерфейс могут быть добавлены новые методы. Если реализация сервера не включает UnimplementedNoteV1Server, то при добавлении нового метода весь код, реализующий NoteV1Server, будет необходимо обновлять, что может привести к множеству ошибок. Включение UnimplementedNoteV1Server позволяет автоматически поддерживать реализацию всех методов, даже если они ещё не реализованы пользователем. Это обеспечивает защиту от поломок при добавлении новых методов.

Простота разработки: UnimplementedNoteV1Server предоставляет базовую реализацию всех методов, которая возвращает ошибку Unimplemented. Таким образом, разработчик может постепенно добавлять реализацию методов, не опасаясь, что его сервер не будет компилироваться из-за отсутствия новых методов.

Принуждение к соблюдению интерфейса: Приватный метод mustEmbedUnimplementedNoteV1Server() делает невозможным реализацию интерфейса NoteV1Server без включения UnimplementedNoteV1Server. Это предотвращает неполные реализации интерфейса, что особенно важно при использовании gRPC, где должны быть соблюдены все контракты между клиентом и сервером.

### Реализация сервера
- **`week_1/grpc/cmd/grpc_server/main.go`**

  Этот файл содержит реализацию gRPC сервера для сервиса `NoteV1`. Структура `server` реализует интерфейс `NoteV1Server`, определённый в `note_grpc.pb.go`. Реализованный метод здесь — `Get`, который использует случайные данные, сгенерированные библиотекой `gofakeit`, чтобы имитировать получение заметки.

  Основные компоненты включают:
    - Настройка сервера (`grpc.NewServer()`)
    - Регистрация сервиса (`desc.RegisterNoteV1Server()`)
    - Реализация сервиса (метод `Get()`, возвращающий фиктивные данные)

### Реализация клиента
- **`week_1/grpc/cmd/grpc_client/main.go`**

  Этот файл содержит реализацию gRPC клиента для тестирования. Он использует `NoteV1Client` для подключения к серверу и выполнения запросов, демонстрируя работу метода `Get` для получения заметки.

  Основные части включают:
    - Установление соединения с сервером (`grpc.Dial()`)
    - Создание нового клиента (`desc.NewNoteV1Client()`)
    - Выполнение запроса с использованием метода `Get()`

### Сравнение размера данных
- **`week_1/grpc/cmd/data_size/main.go`**

  Этот файл сравнивает размеры сериализованных данных `NoteInfo`, используя JSON и Protocol Buffers. Он выводит длину сериализованных данных для обоих форматов (`json.Marshal` и `proto.Marshal`), чтобы показать эффективность Protocol Buffers с точки зрения занимаемого пространства.

### Генераторы кода
- **`bin/protoc-gen-go`** и **`bin/protoc-gen-go-grpc`**

  Это плагины, используемые `protoc` для генерации Go кода из proto-определений. Они устанавливаются как зависимости с помощью команд `Makefile` и являются критически важными для преобразования `.proto` файлов в Go код как для определений сообщений, так и для реализации сервисов.

### Процесс генерации кода
Генерация кода управляется с помощью `Makefile` и компилятора `protoc`. Вот как это работает:
- Цель `generate-note-api` в `Makefile` запускает генерацию кода для API `note_v1`.
- Команда `protoc` принимает proto файл (`note.proto`) и использует установленные плагины (`protoc-gen-go` и `protoc-gen-go-grpc`) для генерации соответствующих файлов `.pb.go` в каталоге `pkg/note_v1`.

Эти сгенерированные файлы предоставляют необходимый Go код для структур сообщений, заглушек клиента и интерфейсов сервера, обеспечивая бесшовное использование gRPC в Go приложениях.

